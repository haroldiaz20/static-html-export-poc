{"version":3,"file":"static/chunks/1.js","sources":["webpack:///./node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js","webpack:///./node_modules/@juggle/resize-observer/lib/ResizeObservation.js","webpack:///./node_modules/@juggle/resize-observer/lib/ResizeObserver.js","webpack:///./node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js","webpack:///./node_modules/@juggle/resize-observer/lib/ResizeObserverController.js","webpack:///./node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js","webpack:///./node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js","webpack:///./node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js","webpack:///./node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js","webpack:///./node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js","webpack:///./node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js","webpack:///./node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js","webpack:///./node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js","webpack:///./node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js","webpack:///./node_modules/@juggle/resize-observer/lib/utils/scheduler.js"],"sourcesContent":["class DOMRectReadOnly {\n    constructor(x, y, width, height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.top = this.y;\n        this.left = this.x;\n        this.bottom = this.top + this.height;\n        this.right = this.left + this.width;\n        return Object.freeze(this);\n    }\n    static fromRect(rectangle) {\n        return new DOMRectReadOnly(rectangle.x, rectangle.y, rectangle.width, rectangle.height);\n    }\n}\nexport { DOMRectReadOnly };\n","import { ResizeObserverBoxOptions } from './ResizeObserverBoxOptions';\nimport { calculateBoxSize } from './algorithms/calculateBoxSize';\nclass ResizeObservation {\n    constructor(target, observedBox) {\n        this.target = target;\n        this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;\n        this.lastReportedSize = {\n            inlineSize: 0,\n            blockSize: 0\n        };\n    }\n    isActive() {\n        const size = calculateBoxSize(this.target, this.observedBox);\n        return this.lastReportedSize.inlineSize !== size.inlineSize\n            || this.lastReportedSize.blockSize !== size.blockSize;\n    }\n}\nexport { ResizeObservation };\n","import { ResizeObserverController } from './ResizeObserverController';\nimport { ResizeObserverBoxOptions } from './ResizeObserverBoxOptions';\nconst DPPB = ResizeObserverBoxOptions.DEVICE_PIXEL_BORDER_BOX;\nexport default class ResizeObserver {\n    constructor(callback) {\n        ResizeObserverController.connect(this, callback);\n    }\n    observe(target, options) {\n        if (options && options.box === DPPB && target.tagName !== 'CANVAS') {\n            throw new Error(`Can only watch ${options.box} on canvas elements.`);\n        }\n        ResizeObserverController.observe(this, target, options);\n    }\n    unobserve(target) {\n        ResizeObserverController.unobserve(this, target);\n    }\n    disconnect() {\n        ResizeObserverController.disconnect(this);\n    }\n    static toString() {\n        return 'function ResizeObserver () { [polyfill code] }';\n    }\n}\nexport { ResizeObserver };\n","var ResizeObserverBoxOptions;\n(function (ResizeObserverBoxOptions) {\n    ResizeObserverBoxOptions[\"BORDER_BOX\"] = \"border-box\";\n    ResizeObserverBoxOptions[\"CONTENT_BOX\"] = \"content-box\";\n    ResizeObserverBoxOptions[\"SCROLL_BOX\"] = \"scroll-box\";\n    ResizeObserverBoxOptions[\"DEVICE_PIXEL_BORDER_BOX\"] = \"device-pixel-border-box\";\n})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));\nexport { ResizeObserverBoxOptions };\n","import { schedule } from './utils/scheduler';\nimport { ResizeObservation } from './ResizeObservation';\nimport { ResizeObserverDetail } from './ResizeObserverDetail';\nimport { hasActiveObservations } from './algorithms/hasActiveObservations';\nimport { hasSkippedObservations } from './algorithms/hasSkippedObservations';\nimport { deliverResizeLoopError } from './algorithms/deliverResizeLoopError';\nimport { broadcastActiveObservations } from './algorithms/broadcastActiveObservations';\nimport { gatherActiveObservationsAtDepth } from './algorithms/gatherActiveObservationsAtDepth';\nconst resizeObservers = [];\nconst observerMap = new Map();\nconst getObservationIndex = (observationTargets, target) => {\n    for (let i = 0; i < observationTargets.length; i += 1) {\n        if (observationTargets[i].target === target) {\n            return i;\n        }\n    }\n    return -1;\n};\nconst process = () => {\n    let depth = 0;\n    gatherActiveObservationsAtDepth(depth);\n    while (hasActiveObservations()) {\n        depth = broadcastActiveObservations();\n        gatherActiveObservationsAtDepth(depth);\n    }\n    if (hasSkippedObservations()) {\n        deliverResizeLoopError();\n    }\n    return depth > 0;\n};\nexport default class ResizeObserverController {\n    static connect(resizeObserver, callback) {\n        const detail = new ResizeObserverDetail(resizeObserver, callback);\n        resizeObservers.push(detail);\n        observerMap.set(resizeObserver, detail);\n    }\n    static observe(resizeObserver, target, options) {\n        if (observerMap.has(resizeObserver)) {\n            const detail = observerMap.get(resizeObserver);\n            if (getObservationIndex(detail.observationTargets, target) < 0) {\n                detail.observationTargets.push(new ResizeObservation(target, options && options.box));\n                schedule();\n            }\n        }\n    }\n    static unobserve(resizeObserver, target) {\n        if (observerMap.has(resizeObserver)) {\n            const detail = observerMap.get(resizeObserver);\n            const index = getObservationIndex(detail.observationTargets, target);\n            if (index >= 0) {\n                detail.observationTargets.splice(index, 1);\n            }\n        }\n    }\n    static disconnect(resizeObserver) {\n        if (observerMap.has(resizeObserver)) {\n            const detail = observerMap.get(resizeObserver);\n            resizeObservers.splice(resizeObservers.indexOf(detail), 1);\n            observerMap.delete(resizeObserver);\n        }\n    }\n}\nexport { ResizeObserverController, resizeObservers, process };\n","class ResizeObserverDetail {\n    constructor(resizeObserver, callback) {\n        this.activeTargets = [];\n        this.skippedTargets = [];\n        this.observationTargets = [];\n        this.observer = resizeObserver;\n        this.callback = callback;\n    }\n}\nexport { ResizeObserverDetail };\n","import { calculateBoxSizes } from './algorithms/calculateBoxSize';\nclass ResizeObserverEntry {\n    constructor(target) {\n        const boxes = calculateBoxSizes(target);\n        this.target = target;\n        this.contentRect = boxes.contentRect;\n        this.borderBoxSize = boxes.borderBoxSize;\n        this.contentSize = boxes.contentBoxSize;\n        this.scrollSize = boxes.scrollBoxSize;\n        this.devicePixelBorderBoxSize = boxes.devicePixelBorderBoxSize;\n    }\n}\nexport { ResizeObserverEntry };\n","import { resizeObservers } from '../ResizeObserverController';\nimport { ResizeObserverEntry } from '../ResizeObserverEntry';\nimport { calculateDepthForNode } from './calculateDepthForNode';\nimport { calculateBoxSize } from './calculateBoxSize';\nconst broadcastActiveObservations = () => {\n    let shallowestDepth = Infinity;\n    const callbacks = [];\n    resizeObservers.forEach((ro) => {\n        if (ro.activeTargets.length === 0) {\n            return;\n        }\n        const entries = [];\n        ro.activeTargets.forEach((ot) => {\n            const entry = new ResizeObserverEntry(ot.target);\n            const targetDepth = calculateDepthForNode(ot.target);\n            entries.push(entry);\n            ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);\n            if (targetDepth < shallowestDepth) {\n                shallowestDepth = targetDepth;\n            }\n        });\n        callbacks.push(() => ro.callback(entries, ro.observer));\n        ro.activeTargets.splice(0, ro.activeTargets.length);\n    });\n    callbacks.forEach(callback => callback());\n    return shallowestDepth;\n};\nexport { broadcastActiveObservations };\n","import { ResizeObserverBoxOptions } from '../ResizeObserverBoxOptions';\nimport { DOMRectReadOnly } from '../DOMRectReadOnly';\nconst cache = new Map();\nconst IE = (/msie|trident/i).test(navigator.userAgent);\nconst parseDimension = (pixel) => parseFloat(pixel || '0');\nconst isSVG = (target) => 'SVGGraphicsElement' in window\n    && target instanceof SVGGraphicsElement && 'getBBox' in target;\nconst calculateBoxSizes = (target) => {\n    if (cache.has(target)) {\n        return cache.get(target);\n    }\n    const svg = isSVG(target) && target.getBBox();\n    const cs = getComputedStyle(target);\n    const removePadding = !IE && cs.boxSizing === 'border-box';\n    const width = parseDimension(cs.width);\n    const height = parseDimension(cs.height);\n    const hidden = isNaN(width) || isNaN(height) || cs.display === 'none';\n    const paddingTop = svg || hidden ? 0 : parseDimension(cs.paddingTop);\n    const paddingRight = svg || hidden ? 0 : parseDimension(cs.paddingRight);\n    const paddingBottom = svg || hidden ? 0 : parseDimension(cs.paddingBottom);\n    const paddingLeft = svg || hidden ? 0 : parseDimension(cs.paddingLeft);\n    const borderTop = svg || hidden ? 0 : parseDimension(cs.borderTopWidth);\n    const borderRight = svg || hidden ? 0 : parseDimension(cs.borderRightWidth);\n    const borderBottom = svg || hidden ? 0 : parseDimension(cs.borderBottomWidth);\n    const borderLeft = svg || hidden ? 0 : parseDimension(cs.borderLeftWidth);\n    const horizontalPadding = paddingLeft + paddingRight;\n    const verticalPadding = paddingTop + paddingBottom;\n    const horizontalBorderArea = borderLeft + borderRight;\n    const verticalBorderArea = borderTop + borderBottom;\n    const widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;\n    const heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;\n    const contentWidth = hidden ? 0 : svg ? svg.width : parseDimension(cs.width) - widthReduction;\n    const contentHeight = hidden ? 0 : svg ? svg.height : parseDimension(cs.height) - heightReduction;\n    const borderBoxSize = {\n        inlineSize: contentWidth + horizontalPadding + horizontalBorderArea,\n        blockSize: contentHeight + verticalPadding + verticalBorderArea\n    };\n    const contentBoxSize = {\n        inlineSize: contentWidth,\n        blockSize: contentHeight\n    };\n    const scrollBoxSize = {\n        inlineSize: contentWidth + horizontalPadding,\n        blockSize: contentHeight + verticalPadding\n    };\n    const devicePixelBorderBoxSize = {\n        inlineSize: borderBoxSize.inlineSize * window.devicePixelRatio,\n        blockSize: borderBoxSize.blockSize * window.devicePixelRatio\n    };\n    const contentRect = new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight);\n    const boxes = {\n        borderBoxSize,\n        contentBoxSize,\n        scrollBoxSize,\n        devicePixelBorderBoxSize,\n        contentRect\n    };\n    cache.set(target, boxes);\n    return boxes;\n};\nconst calculateBoxSize = (target, observedBox) => {\n    const boxes = calculateBoxSizes(target);\n    switch (observedBox) {\n        case ResizeObserverBoxOptions.BORDER_BOX:\n            return boxes.borderBoxSize;\n        case ResizeObserverBoxOptions.SCROLL_BOX:\n            return boxes.scrollBoxSize;\n        case ResizeObserverBoxOptions.DEVICE_PIXEL_BORDER_BOX:\n            return boxes.devicePixelBorderBoxSize;\n        case ResizeObserverBoxOptions.CONTENT_BOX:\n        default:\n            return boxes.contentBoxSize;\n    }\n};\nexport { calculateBoxSize, calculateBoxSizes, cache };\n","const calculateDepthForNode = (node) => {\n    let depth = 0;\n    let parent = node.parentNode;\n    while (parent) {\n        depth += 1;\n        parent = parent.parentNode;\n    }\n    return depth;\n};\nexport { calculateDepthForNode };\n","const msg = 'ResizeObserver loop completed with undelivered notifications.';\nconst deliverResizeLoopError = () => {\n    let event;\n    if (typeof ErrorEvent === 'function') {\n        event = new ErrorEvent('error', {\n            message: msg\n        });\n    }\n    else {\n        event = document.createEvent('Event');\n        event.initEvent('error', false, false);\n        event.message = msg;\n    }\n    window.dispatchEvent(event);\n};\nexport { deliverResizeLoopError };\n","import { resizeObservers } from '../ResizeObserverController';\nimport { calculateDepthForNode } from './calculateDepthForNode';\nimport { cache as boxCache } from './calculateBoxSize';\nconst gatherActiveObservationsAtDepth = (depth) => {\n    boxCache.clear();\n    resizeObservers.forEach((ro) => {\n        ro.activeTargets.splice(0, ro.activeTargets.length);\n        ro.skippedTargets.splice(0, ro.skippedTargets.length);\n        ro.observationTargets.forEach((ot) => {\n            if (ot.isActive()) {\n                if (calculateDepthForNode(ot.target) > depth) {\n                    ro.activeTargets.push(ot);\n                }\n                else {\n                    ro.skippedTargets.push(ot);\n                }\n            }\n        });\n    });\n};\nexport { gatherActiveObservationsAtDepth };\n","import { resizeObservers } from '../ResizeObserverController';\nconst hasActiveObservations = () => {\n    return resizeObservers.some((ro) => ro.activeTargets.length > 0);\n};\nexport { hasActiveObservations };\n","import { resizeObservers } from '../ResizeObserverController';\nconst hasSkippedObservations = () => {\n    return resizeObservers.some((ro) => ro.skippedTargets.length > 0);\n};\nexport { hasSkippedObservations };\n","import { process } from '../ResizeObserverController';\nconst events = [\n    'resize',\n    'transitionend',\n    'animationend',\n    'animationstart',\n    'animationiteration',\n    'keyup',\n    'keydown',\n    'mouseup',\n    'mousedown',\n    'mouseover',\n    'mouseout',\n    'blur',\n    'focus'\n];\nlet frameId;\nconst run = (frames) => {\n    cancelAnimationFrame(frameId);\n    frameId = requestAnimationFrame(() => {\n        if (process()) {\n            run(60);\n        }\n        else if (frames) {\n            run(frames - 1);\n        }\n    });\n};\nconst schedule = () => run(1);\nevents.forEach(name => window.addEventListener(name, schedule, true));\nconst createObserver = () => {\n    if ('MutationObserver' in window) {\n        const observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };\n        new MutationObserver(schedule).observe(document.body, observerConfig);\n    }\n};\ndocument.body ? createObserver() : document.addEventListener('DOMContentLoaded', createObserver);\nexport { schedule };\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChBA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9DA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACTA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1EA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACTA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACfA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}